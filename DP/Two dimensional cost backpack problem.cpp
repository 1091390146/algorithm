// 问题
// 二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]。

// 算法
// 费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：

// f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}

// 如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。这里就不再给出伪代码了，相信有了前面的基础，你能够自己实现出这个问题的程序。

//**** 物品总个数的限制***
// 有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。

// 复数域上的背包问题
// 另一种看待二维背包问题的思路是：将它看待成复数域上的背包问题。也就是说，背包的容量以及每件物品的费用都是一个复数。而常见的一维背包问题则是实数域上的背包问题。（注意：上面的话其实不严谨，因为事实上我们处理的都只是整数而已。）所以说，一维背包的种种思想方法，往往可以应用于二位背包问题的求解中，因为只是数域扩大了而已。

// 作为这种思想的练习，你可以尝试将P11中提到的“子集和问题”扩展到复数域（即二维），并试图用同样的复杂度解决。

//有2n个整数，平均分成两组，每组n个数，使这两组数的和最接近。这里对应的就是物品总个数的限制

#include <vector>
#include <stdio.h>
#define max(x, y) x > y ? x : y

using namespace std;

int main(){
    int N , M1, M2;
    scanf("%d %d %d", &N, &M1, &M2);
    vector<int> value(N + 1, 0);
    vector<int> weight1(N + 1, 0);
    vector<int> weight2(N + 1, 0);
    vector<vector<int>> f(M1 + 1, vector<int>(M2 + 1, 0));
    for(int i = 1; i <= N; ++i){
        scanf("%d %d %d", &value[i], &weight1[i], &weight2[i]);
    }
    for(int i = 1; i <= N; ++i){
        for(int j = M1; j >= weight1[i]; --j){
            for(int k = M2; k >= weight2[i]; --k)
                f[j][k] = max(f[j][k], f[j - weight1[i]][k - weight2[i]] + value[i]);
        }
    }
    printf("%d", f[M1][M2]);
    getchar();
    getchar();
    return 0;
}

//https://blog.csdn.net/yandaoqiusheng/article/details/84782655

//子集和打印问题，我的思路：
// 1、比如直接给一个集合，打印出来里面和为sum的集合，直接用bfs去做；
// 2、一个集合，分成两组，两组之间和的差的绝对值最小，先通过01背包问题找到sum/2处的最优解num，然后
// 通过bfs找到最优解的集合，这个集合就是一组，另一组也随之求出来了；
// 3、有2n个整数，平均分成两组，每组n个数，使这两组数的和最接近。这里对应的就是物品总个数的限制；
// 这样的问题在于一组集合数量给定了，相当于二维背包的物品总个数限制，最多只能取M件，放到这个问题中就是最多
// 只能取n件，将上面循环中m换成n，L换成sum/2，最后dp[n][sum/2]处的值就是均分两组其中一组的最优解，只要求出
// 这n个数，另外n个数迎刃而解，知道了n，知道了最优解，用bfs去搜寻打印，就可以了；