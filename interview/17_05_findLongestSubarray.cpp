#include <vector>
#include <algorithm>
#include <string>
#include <unordered_map>

using namespace std;

/*
面试题 17.05.  字母与数字
给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。

返回该子数组，若存在多个最长子数组，返回左端点最小的。若不存在这样的数组，返回一个空数组。

示例 1:

输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
示例 2:

输入: ["A","A"]

输出: []
*/

/*
思路
数字看成-1，字母看成1，再计算前缀和。
前缀和 相同则计算下标的差值。

技巧：使用int[]数组memo存储 该前缀和 第1次出现时 的下标。
为何是第1次出现时的下标？
因为要求最长子数组。

比如：
["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

转化为[1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1]

再转为前缀和形式[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]。

前缀和相同是什么意思呢？

比如看加粗的2个1：[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]

说明这2个1的下标所构成的区间内的数字和为0，而数字和为0说明有相同个数的1和-1，即相同个数的字母和数字。

具体来说：第1个加粗的1下标为0，第2个加粗的1下标为2，构成区间(0, 2](注意：是半开半闭)，
区间(0, 2]内元素的和即下标为1和下标为2的元素之和，[1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1]
很明显-1 + 1 = 0

理解了这一点，剩余的工作就是找前缀和相同，且相隔最远的2个元素。

什么才是相隔最远？

[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]

单只看前缀和为1的情况，毫无疑问，前缀和为1时，相隔最远的肯定是最左边的1和最右边的1.

因此我们只需要记录前缀和为1第一次出现时的下标即可(也就是记录了最左边的1的位置)，以后再遇到前缀和为1时，只需要将其下标 - 所记录的最左边的1的位置 即可。

至于memo数组大小为何初始化为(len << 1) + 1，考虑最极端的情况，要么全为-1，要么全为1，对应前缀和为-array.length和array.length。

特别注意:
当前缀和为0时，假设其下标为n，则说明区间[0, n]内所有元素的和为0，区间长度为n + 1。
因此将memo[0 + array.length]的值设为-1，因为n - (-1) = n + 1。

同时由于数组下标不能为负数，因此需要映射处理:
假设数组有2个元素，边界值为-2和2，即[-2, -1, 0, 1, 2]。
将[-2, -1, 0, 1, 2] 集体右移nums.length个单位，映射为[0, 1, 2, 3, 4]。
*/

class Solution {
public:
    vector<string> findLongestSubarray(vector<string>& array) {
        int n=array.size();
        vector<int> prefix(n,0);
        unordered_map<int,int> M;   //key,left_index
        int left=0,right=-1;
        for(int i=0;i<n;++i){
            char ch=array[i][0];
            if(ch>='A' && ch<='z') prefix[i]=-1;
            else prefix[i]=1;
        }

        for(int i=1;i<n;++i){
            prefix[i]+=prefix[i-1];
        }

        for(int i=0;i<n;++i){
            auto it=M.find(prefix[i]);
            if(prefix[i]==0){
                if(right-left+1 < i+1){
                    right=i;left=0;
                }
                continue;
            }
            if(it==M.end()) M[prefix[i]]=i;
            else {
                if(right-left+1 < i-it->second){
                    right=i;left=it->second+1;
                }
            }
        }
        vector<string> ans;
        for(int i=left;i<=right;++i) ans.push_back(array[i]);
        return ans;
    }
};
